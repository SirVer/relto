#![feature(path_relative_from)]

use std::env;
use std::io::{self, Read, stdin};
use std::path;

extern crate clap;
use clap::{Arg, App, SubCommand};

fn make_absolute(path: &path::Path, current_dir: &path::Path) -> path::PathBuf {
    if path.is_absolute() {
        path.to_owned()
    } else {
        current_dir.join(path)
    }
}

fn main() {
    let matches = App::new("relto")
                      .version("1.0")
                      .author("Holger Rapp <HolgeRapp@gmx.net>")
                      .about("Prints input paths relative to a directory.")
                      .arg(Arg::with_name("DIR")
                               .short("d")
                               .long("dir")
                               .help("Directory to find relative path to. [.]")
                               .takes_value(true))
                      .arg(Arg::with_name("paths")
                               .multiple(true)
                               .help("The input paths."))
                      .get_matches();

    let current_dir = env::current_dir().unwrap();
    let dir = make_absolute(&matches.value_of("DIR")
                     .map(|s| path::PathBuf::from(s))
                     .unwrap_or(current_dir), &current_dir);
    for path in matches.values_of("paths").unwrap_or(vec![]) {
        let mut path = path::Path::new(path);
        let absolute_path = make_absolute(&path, &current_dir);
        let relative_path = absolute_path.relative_from(&dir).unwrap();
        println!("{}", relative_path.to_string_lossy());
    }
}
